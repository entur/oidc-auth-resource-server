package org.entur.auth.junit.tenant;

import com.github.tomakehurst.wiremock.WireMockServer;
import java.lang.annotation.Annotation;
import java.util.Map;
import java.util.Optional;
import lombok.extern.slf4j.Slf4j;
import org.entur.auth.JwtTokenFactory;
import org.entur.auth.PortReservation;
import org.entur.auth.WireMockAuthenticationServer;
import org.junit.jupiter.api.extension.BeforeAllCallback;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.api.extension.ParameterResolutionException;
import org.junit.jupiter.api.extension.ParameterResolver;

/**
 * TenantJsonWebToken is a JUnit extension that implements both {@link
 * org.junit.jupiter.api.extension.ParameterResolver} and {@link
 * org.junit.jupiter.api.extension.BeforeEachCallback} to support the injection and generation of
 * tenant-specific JSON Web Tokens (JWT) during testing.
 *
 * <p>This extension sets up a WireMock authentication server, reserves a port, and initializes the
 * JWT token factories needed to create tokens for different tenant types. It supports injection for
 * parameters that are annotated with tenant-specific annotations (such as {@code PartnerTenant},
 * {@code InternalTenant}, {@code TravellerTenant}, and {@code PersonTenant}), as well as for
 * parameters of type {@link org.entur.auth.junit.tenant.TenantAnnotationTokenFactory} or {@link
 * com.github.tomakehurst.wiremock.WireMockServer}.
 *
 * <p>The supported tenant types are defined by the {@code SUPPORTED_TENANTS} array and correspond
 * to constants provided by the {@link org.entur.auth.junit.tenant.EnturProvider}.
 */
@Slf4j
public class TenantJsonWebToken
        implements ParameterResolver, BeforeEachCallback, BeforeAllCallback {
    /** The name used for reserving the port for the mock authentication server. */
    public static final String MOCKAUTHSERVER_PORT_NAME = "MOCKAUTHSERVER_PORT";

    /**
     * Map of Tenant identifiers supported by the JWT token factory -> tenant-specific annotation
     * types that this extension supports.
     */
    private static final Map<String, Class<? extends Annotation>> TENANT_MAP =
            Map.of(
                    EnturProvider.TENANT_PARTNER, PartnerTenant.class,
                    EnturProvider.TENANT_INTERNAL, InternalTenant.class,
                    EnturProvider.TENANT_TRAVELLER, TravellerTenant.class,
                    EnturProvider.TENANT_PERSON, PersonTenant.class);

    private static TenantAnnotationTokenFactory tokenFactory;
    private static PortReservation portReservation;

    /**
     * This before all callback initializes the WireMock authentication server, the JWT token factory,
     * and the certificate mappings.
     */
    @Override
    public void beforeAll(ExtensionContext context) {
        setupPortReservation();
        setupTokenFactory();
    }

    /**
     * Callback that is invoked before each test execution.
     *
     * <p>This method ensures that the WireMock server is running before each test.
     *
     * @param context the current extension context; never {@code null}
     */
    @Override
    public void beforeEach(ExtensionContext context) {
        startIfNotRunning();
    }

    /**
     * Determines if the given parameter is supported by this extension.
     *
     * <p>A parameter is considered supported if it is annotated with one of the tenant annotations,
     * or if its type is either {@link org.entur.auth.junit.tenant.TenantAnnotationTokenFactory} or
     * {@link com.github.tomakehurst.wiremock.WireMockServer}.
     *
     * @param parameterContext the context for the parameter to be resolved
     * @param extensionContext the current extension context; never {@code null}
     * @return {@code true} if the parameter is supported; {@code false} otherwise
     * @throws org.junit.jupiter.api.extension.ParameterResolutionException if parameter resolution
     *     fails
     */
    @Override
    public boolean supportsParameter(
            ParameterContext parameterContext, ExtensionContext extensionContext)
            throws ParameterResolutionException {
        for (Class<? extends Annotation> c : TENANT_MAP.values()) {
            if (parameterContext.findAnnotation(c).isPresent()) {
                return true;
            }
        }
        if (parameterContext.getParameter().getType() == TenantAnnotationTokenFactory.class) {
            return true;
        }

        return parameterContext.getParameter().getType() == WireMockServer.class;
    }

    /**
     * Resolves the parameter for injection.
     *
     * <p>For parameters annotated with a tenant-specific annotation, this method returns a JSON Web
     * Token generated by the {@link org.entur.auth.junit.tenant.TenantAnnotationTokenFactory}. For
     * parameters of type {@link org.entur.auth.junit.tenant.TenantAnnotationTokenFactory}, it returns
     * the token factory instance.
     *
     * @param parameterContext the context for the parameter to be resolved
     * @param extensionContext the current extension context; never {@code null}
     * @return the resolved parameter value
     * @throws org.junit.jupiter.api.extension.ParameterResolutionException if the parameter cannot be
     *     resolved
     */
    @Override
    public Object resolveParameter(
            ParameterContext parameterContext, ExtensionContext extensionContext)
            throws ParameterResolutionException {
        for (var entry : TENANT_MAP.entrySet()) {
            Optional<? extends Annotation> annotation = parameterContext.findAnnotation(entry.getValue());
            if (annotation.isPresent()) {
                return tokenFactory.createToken(annotation.get());
            }
        }
        if (parameterContext.getParameter().getType() == TenantAnnotationTokenFactory.class) {
            return tokenFactory;
        }
        if (parameterContext.getParameter().getType() == WireMockServer.class) {
            return tokenFactory.getServer().getMockServer();
        }
        throw new CanNotResolveParameterException();
    }

    private static void setupPortReservation() {
        // this code should run before the spring context starts, but in case the class is not loaded,
        // the spring context will run first.
        // In which case the MOCKAUTHSERVER_PORT port must be a free port.
        if (portReservation == null) {
            portReservation = new PortReservation(MOCKAUTHSERVER_PORT_NAME);
        }

        // Reserve port
        if (portReservation.getPort() < 0) {
            portReservation.start();
        }
    }

    private static void setupTokenFactory() {
        // Run with a fixed set of certificates so that spring context reuse works:
        // Context A loads the certificates, context B (i.e. not-dirty A context) uses those
        // certificates to validate tokens.
        if (tokenFactory == null) {
            log.info("Setup mock server was on port {}", portReservation.getPort());
            var provider = new EnturProvider();
            var jwtTokenFactory = new JwtTokenFactory(provider);
            var server = new WireMockAuthenticationServer(portReservation.getPort());
            tokenFactory = new TenantAnnotationTokenFactory(provider, jwtTokenFactory, server);
        }
    }

    private static void startIfNotRunning() {
        var server = tokenFactory.getServer();
        if (!server.isRunning()) {
            log.info("Starting mock server on port {}", portReservation.getPort());
            portReservation.stop();
            server.start();
        }
    }
}
